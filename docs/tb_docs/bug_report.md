# Bug Report
This document summarizes RTL logic issues and assertion findings identified during functional verification of the Sauria Subsystem.

## RTL Logic Findings

### Core Main Controller
| Title               | BUG_ID  | File    |Description           | Proposed Fix               |
|--------------------|-------|-------|-----------|------------------|
| Context Switch FSM Hangs Waiting For Data Feeders Completion | CORE_BUGID1 | context_fsm.sv | If the size of the partial sums tile is smaller than the ifmaps tile, then the psums manager can finish before the data feeder is done. In order for the data feeder to continue, its fifos cannot be full, so therefore a pop operation must occur. The context controller and context fsm prevent this action because they wait on the data feeders and the partial sums manager to load their corresponsing tiles before proceeding with a context switch. The resulting scenario is a circular dependency, where the data feeder needs its fifos to be popped so it can continue feeding, and the context fsm needs the data feeder to complete before it can continue. | Remove the dependency of the data feeder completion from the condition to initiate a context switch within the context switch fsm and only rely on the indication from the partial sums manager. |
| Same Addresses Are Accessed from SRAMC On Different Partial Sums Contexts | CORE_BUGID2 | psm_idxcnt.sv | The address used to access SRAM_C and read partial sums preload values is created from the index counters in the partial sums manager. The x and k counters are reset on every context. Because they are reset, they start counting at 0 on every context, instead of starting to count from the next context. | Remove the counter clear condition on X and K index counters. |
| Incorrect Partial Sums Address Sequence When Switching Operation| CORE_BUGID3 |  psm_idxcnt.sv | The counters used for the x and k dimension are generic counters and keep only one copy of the count values. When operation is switched from read to write or write to read, the counters continue to count instead of starting to count from the last address in the next operation. | Change the x and y counters to be dual counters similar to how the tile X and tile K counters operate such that the read and write operations will have individual count values for each counter. |
| Partial Sums SRAMC Address Does Not Include Tile Index| CORE_BUGID4 |  psm_idxcnt.sv | The calculation for sram c index is currently missing the tile index. This does not break functionality for when the psums manager is configured to read a single tile, but when multiple tiles are meant to be read, this would result in reading the same set of addresses across tiles. | Include the tile index in the sram c index calculation. |
| Partial Sums Shift FSM Can Start After All Contexts Complete| CORE_BUGID5 |  psm_shift_fsm.sv | The next state logic for the idle state of the partial sums shift fsm allows the fsm to change states when all contexts have been completed. This creates potential hangs from the fsm waiting for inputs from other parts of the core to complete when none should be expected due to the completion of all contexts. | Place the condition of not completion_flag at the first conditional statement of the idle state such that the fsm rejects all inputs once the flag has been set. |

| Partial Sums Manager's Read/Write Indication to SRAM Stays Asserted For Too Long | CORE_BUGID6 |  psm_shift_fsm.sv | After index count limit has been hit indicating that we are reading/writing from/to the last address, the read_feed_en and write_feed_en stay high for extra cycles due to state transitions. This results in reading/writing from/to the +1 address. | Modify the read and write state behaviors to drop the read_feed_en and write_feed_en as soon as the indication has come in that the count has reached its limit, rather than depending on the next state behavior to drop the enable signals. |


### Dataflow Controller
| Title               | BUG_ID  | File    |Description           | Proposed Fix               |
|--------------------|-------|-------|-----------|------------------|
| Incorrect awaddr is sent on SEND_CMD state for dma controller | DF_BUGID1 | sauria_dma_controller.sv | RTL shows intention of having wvalid assert a cycle after awvalid assertion to give a chance of the awaddr to be latched. Instead awvalid and wvalid assert concurrently thus the incorrect address is written to | Use awvalid and wvalid in the state logic to determine addr_sent and data sent, instead of using awready and wready. |
| SEND_CMD State Deadlocked | DF_BUGID2 | sauria_dma_controller.sv | The SEND_CMD state is supposed to send multiple CSR writes to the DMA engine to initiate a read to memory. After the first CSR write has been issued, the state is deadlocked and cannot issue any more writes due to incorrect condition. | Simplify the initial entry condition to send a CSR write to be based on addr and data sent indications. |
| Incorrect Data Sent To DMA CSRs | DF_BUGID3 | sauria_dma_controller.sv | Some DMA CSRs have single bit fields while others have full CSR length fields. When a full length CSR has been written to, the bit are never cleared again for the CSRs which have single bit fields. As a result, those bits stay sticky. | Update data write to start with all 0s whenever there is a CSR which has single bit fields so that sticky previous bits are cleared. |
| DMA Controller FSM Fails to Start Read/Write DMA Engine After First Iteration | DF_BUGID4 | sauria_dma_controller.sv | SYNC_WRESP state behavior only sends the start read/write DMA csr on the first iteration, on other iterations it waits for reader interrupt which deadlocks the fsm. The reader interrupt indication never arrives because the reader engine was never started. | Update next state logic to remove condition for first iteration and make every iteration go to SEND_START_ADDR |
| Divergent Paths After Write Response | DF_BUGID5 | sauria_dma_controller.sv | WAIT_START_WRESP is meant to wait for the DMA engine to finish writing to the SRAMs. It is written as to not wait extra time, so it chooses different paths whether you see the axi4-lite write response or the write interrupt from the dma engine. This however inadvertently leads to divergent paths, as the bvalid next state path and the dma writer interrupt path don't converge | Update next state logic to wait for write dma interrupt in all cases once the write response (bvalid) has been asserted. This leads to a longer path but forces convergence. |
| Write Interrupt Failed to Be Cleared |DF_BUGID6 | sauria_dma_controller.sv | WAIT_DMA_INTR_READER is meant to wait for the dma reader interrupt and then clear the interrupt indication. It only clears the read interrupt and depends on the WAIT_DMA_INTR_WRITER state to clear the writer interrupt. However, because WAIT_DMA_INTR_READER can lead to different next state paths, sometimes the dma writer interrupt remains uncleared. | Clear both the read and write interrupt regardless of which one we are waiting for. |
| Extra Start DMA Reader/Writer Engine Sent After Read/Write Complete | DF_BUGID7 | sauria_dma_controller.sv | Once the DMA engine finishes reading the tile from memory and writing it to SRAM, we determine what to do next (eg. advance tile pointer). At this point, a start DMA reader/write command is sent yet again.  | Update next state logic of WAIT_CLR_INTR_WRESP to go straight to CHECK_NEXT_ACTION so that it can be determined what to do next. | 
| Tile Pointer Fails to Advance After Tile Has Been Read By DMA | DF_BUGID8 | sauria_dma_controller.sv | After the DMA engine finishes reading the tile from memory and writing it to SRAM, we start the tensor core fsm and wait for the computation to complete. Once computation completes we set the DF controller to transfer the partial sums to memory. In order to do this, we must synchronize with the tensor core. The next state logic for DMA controller FSM does not move to the core sync state once the entire tile has been read. Instead, it moves to wait for the read interrupt signal from the DMA engine to arrive which it never does but it already completed the last read for the current tile. Thus you end up deadlocking the FSM. | Update next state logic of CHECK_NEXT_ACTION to go straight to SAURIA_SYNC once the tiles for IFMAPS, WEIGHTS (optionally), and PSUMS have been read. | 
| Last Two Iterations of Tensor Loops Deadlock Dataflow FSM | DF_BUGID9 | sauria_dma_controller.sv | After the computation has been completed and the partial sums are transferred to memory, we have two extra iterations in which we sync the dataflow controller fsm with the dma controller fsm. This sync is deadlocked because the dma controller moves to a state where it waits for a DMA reader interrupt, which it never arrives because there aren't any pending reads left. All of the DMA reads/writes have been completed at this time. | Update next state logic of CHECK_NEXT_ACTION at the stage where the partial sums have finished being written to memory, to go directly to SAURIA_SYNC. | 
| Flattening Y and K Psums Dimensions With Ck_eq and Ch_eq Deadlocks DF FSM | DF_BUGID10 | sauria_dma_controller.sv | Incorrect next state is set for the case where psums Y and K dimensions have been flattened and weights have finished being read. At that point, the intent is to start the computation, and wait for it to complete, and then send the partial sums to memory. The fsm prepares to do that, but it jumps to a state where it waits for the dma to send a read interrupt, which it won't do because it has finished sending reads for the moment. The next dma operations will be writes to memory. Because of this, the dma controller fsm is deadlocked.| Change the next state condition to SAURIA_SYNC state where it waits for the sauria core to complete the tile computation. | 
| Incorrect Tensor Read On Second Iter When Loop_Order = 2 | DF_BUGID11 | sauria_dma_controller.sv | After the first full iteration completes, meaning all current tile ifmaps, weights, and psums have been read, the dma controller starts to read the next ifmaps tile. This order is correct except when loop_order is set to 2. In that case, the K dimension is the fastest moving, and reading ifmaps would result in reading the same ifmaps tile again uneccessarily.| Create condition that changes behavior for this case when loop order is 2. Behvaior should be to prepare the dma controller fsm  to start reading the next weights tile. | 


            
### DMA Engine
| Title               | BUG_ID  | File    |Description           | Proposed Fix               |
|--------------------|-------|-------|-----------|------------------|
| DMA Engine Enforces Bus Width Address Alignment | DMA_BUGID1 | transaction_generator.sv | In order to minimize the number of DMA transactions, the DMA engine enforces read and write addresses to be aligned to the width of the memory bus. If a tile dimension is smaller than the width of the bus, then the same read request address will be repeated multiple times during the reading of a tile. | Modify the transaction generator within the DMA engine to send the exact address it received from the dataflow controller as the read/write address in its requests. Even if this implementation makes for worse performance, it gives flexibility on the sizes of tiles which are correctly supported. |
| Response Ready Not Propogated For DMA Demux When Empty Fifo | DMA_BUGID2 | axi_demux.sv | The dma engine uses a demux to syncronize or choose who to transmit to/from next. This is the mechanism that selects to either read/write to/from memory or read/write to/from SRAMs. The logic for the response ready and assertion between masters and slaves, depend on the w fifo not being empty. If it is, then dma responses ready never asserts and the transaction never completes. | Remove the fifo not empty condition from the master response logic. |
| Response Ready Not Propogated For DMA Demux When Empty Fifo | DMA_BUGID3 | fifo_v3.sv | The dma engine uses a demux to syncronize or choose who to transmit to/from next. This is the mechanism that selects to either read/write to/from memory or read/write to/from SRAMs. When the fifo is empty, the last value in the fifo gets sent out as the select, causing the demux to choose the incorrect port (MEM v SRAM) as the next interaction, leading to blocking of the dataflow and execution of the subsystem | Remove the fifo not empty condition from the master response logic. |
| Incorrect ARSIZE and AWSIZE Set | DMA_BUGID4 | ar_engine.sv aw_engine.sv | The AR and AW engine current implementation sets arsize and awsize according to the fixed memory bus width of 128 bytes. | Modify implementatio to set arsize and awsize using btt instead of the fixed bus width. |
| Incorrect First Chunk Data Sent To SRAMs | DMA_BUGID5 | data_fifo.sv | The write to the internal DMA memory from the DMA read to external memory and the read from the internal DMA memory to write to SRAM occurs in the same cycle which means that we are reading old data from the internal DMA memory. | Extend the DMA internal memory read pipeline to add 2 cycles of delay such that we can read the newly written data. Add parameter to data_fifo module to choose this change only for writer fifo. |
| AW and W Channel Deadlock | DMA_BUGID6 | aw_engine.sv w_engine.sv | DMA_BUGID5 impacts the aw and w engine pipelines because the writer fifo empty indications are used to create the aw_valid and w_valid pulses. The number of pulses becomes incorrect which in turn can lead to deadlock of these engines. | Extend the AW and W engine pipelines to add 2 cycles of delay to the fifo empty indication being used to create the AW valid and W valid pulses. Set the AW_W_SYNC parameter to 1 to guarantee that these two engines synchronize with each other |


       