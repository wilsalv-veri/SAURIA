# Bug Report
This document summarizes RTL logic issues and assertion findings identified during functional verification of the Sauria Subsystem.

## RTL Logic Findings

### Dataflow Controller
| Title               | BUG_ID  | File    |Description           | Proposed Fix               |
|--------------------|-------|-------|-----------|------------------|
| Incorrect awaddr is sent on SEND_CMD state for dma controller | DF_BUGID1 | sauria_dma_controller.sv | RTL shows intention of having wvalid assert a cycle after awvalid assertion to give a chance of the awaddr to be latched. Instead awvalid and wvalid assert concurrently thus the incorrect address is written to | Use awvalid and wvalid in the state logic to determine addr_sent and data sent, instead of using awready and wready. |
| SEND_CMD State Deadlocked | DF_BUGID2 | sauria_dma_controller.sv | The SEND_CMD state is supposed to send multiple CSR writes to the DMA engine to initiate a read to memory. After the first CSR write has been issued, the state is deadlocked and cannot issue any more writes due to incorrect condition. | Simplify the initial entry condition to send a CSR write to be based on addr and data sent indications. |
| Incorrect Data Sent To DMA CSRs | DF_BUGID3 | sauria_dma_controller.sv | Some DMA CSRs have single bit fields while others have full CSR length fields. When a full length CSR has been written to, the bit are never cleared again for the CSRs which have single bit fields. As a result, those bits stay sticky. | Update data write to start with all 0s whenever there is a CSR which has single bit fields so that sticky previous bits are cleared. |
| DMA Controller FSM Fails to Start Read/Write DMA Engine After First Iteration | DF_BUGID4 | sauria_dma_controller.sv | SYNC_WRESP state behavior only sends the start read/write DMA csr on the first iteration, on other iterations it waits for reader interrupt which deadlocks the fsm. The reader interrupt indication never arrives because the reader engine was never started. | Update next state logic to remove condition for first iteration and make every iteration go to SEND_START_ADDR |
| Divergent Paths After Write Response | DF_BUGID5 | sauria_dma_controller.sv | WAIT_START_WRESP is meant to wait for the DMA engine to finish writing to the SRAMs. It is written as to not wait extra time, so it chooses different paths whether you see the axi4-lite write response or the write interrupt from the dma engine. This however inadvertently leads to divergent paths, as the bvalid next state path and the dma writer interrupt path don't converge | Update next state logic to wait for write dma interrupt in all cases once the write response (bvalid) has been asserted. This leads to a longer path but forces convergence. |
| Write Interrupt Failed to Be Cleared |DF_BUGID6 | sauria_dma_controller.sv | WAIT_DMA_INTR_READER is meant to wait for the dma reader interrupt and then clear the interrupt indication. It only clears the read interrupt and depends on the WAIT_DMA_INTR_WRITER state to clear the writer interrupt. However, because WAIT_DMA_INTR_READER can lead to different next state paths, sometimes the dma writer interrupt remains uncleared. | Clear both the read and write interrupt regardless of which one we are waiting for. |
| Extra Start DMA Reader/Writer Engine Sent After Read/Write Complete | DF_BUGID7 | sauria_dma_controller.sv | Once the DMA engine finishes reading the tile from memory and writing it to SRAM, we determine what to do next (eg. advance tile pointer). At this point, a start DMA reader/write command is sent yet again.  | Update next state logic of WAIT_CLR_INTR_WRESP to go straight to CHECK_NEXT_ACTION so that it can be determined what to do next. | 
| Tile Pointer Fails to Advance After Tile Has Been Read By DMA | DF_BUGID8 | sauria_dma_controller.sv | After the DMA engine finishes reading the tile from memory and writing it to SRAM, we start the tensor core fsm and wait for the computation to complete. Once computation completes we set the DF controller to transfer the partial sums to memory. In order to do this, we must synchronize with the tensor core. The next state logic for DMA controller FSM does not move to the core sync state once the entire tile has been read. Instead, it moves to wait for the read interrupt signal from the DMA engine to arrive which it never does but it already completed the last read for the current tile. Thus you end up deadlocking the FSM. | Update next state logic of CHECK_NEXT_ACTION to go straight to SAURIA_SYNC once the tiles for IFMAPS, WEIGHTS (optionally), and PSUMS have been read. | 
| Last Two Iterations of Tensor Loops Deadlock Dataflow FSM | DF_BUGID9 | sauria_dma_controller.sv | After the computation has been completed and the partial sums are transferred to memory, we have two extra iterations in which we sync the dataflow controller fsm with the dma controller fsm. This sync is deadlocked because the dma controller moves to a state where it waits for a DMA reader interrupt, which it never arrives because there aren't any pending reads left. All of the DMA reads/writes have been completed at this time. | Update next state logic of CHECK_NEXT_ACTION at the stage where the partial sums have finished being written to memory, to go directly to SAURIA_SYNC. | 
| Partial Sum K Lim Formula Uses Tile K Step Instead of W Step | DF_BUGID10 | sauria_interface.sv | When WXfer_op is not set, the current partial sum k limit is based on tile partial sum K step. Tile partial sum k step is the size of a partial sum tile times C tiles. This does not reflect the length of the K dimension. What does represent the k dimension for the partial sums tile is the k dimension of a weights tile, which is w limit. | Change partial sum k lim to always rely on weights w_step, not only when WXfer_op is set. | 
| Partial Sum Y Lim Formula Uses Tile Partial Sum Y Step | DF_BUGID11 | sauria_interface.sv | The fastest running tile dimension is X. Therefore, when calculating the Y limit of a single partial sum tile, it would make most sense to use the fastest running dimension in the formula. Tile partial sum y step is a multiple of tile partial sum x step.| Replace tile partial sum y step with tile partial sum x step in the calculation formula for y limit of a single partial sum tile. | 
| Incorrect Number of Elements Sent Per Weights DMA Read Req | DF_BUGID12 | sauria_interface.sv | Each DMA read request for a weights tile should be of K dimension. Current implementation is setting it to tile weights K step, which is equivalent to the size of multiple weights tiles, exactly C number of them.| Use the weights wstep as the number of elements per DMA weights read request. This should be programmed to the value of the K dimension. | 
| Incorrect Number of Elements Sent Per Partial Sum DMA Read Req | DF_BUGID13 | sauria_interface.sv | Each DMA read request for a partial sums tile should be of X dimension. Current implementation is setting it to tile partial sum x step, which is equivalent to the size of an entire partial sum tile.| Use the X dimension for an IFMAPS tile to get the X dimension of a partial sum tile. By architectural intent, these two should match. | 
        
### DMA Engine
| Title               | BUG_ID  | File    |Description           | Proposed Fix               |
|--------------------|-------|-------|-----------|------------------|
| DMA Engine Enforces Bus Width Address Alignment | DMA_BUGID1 | transaction_generator.sv | In order to minimize the number of DMA transactions, the DMA engine enforces read and write addresses to be aligned to the width of the memory bus. If a tile dimension is smaller than the width of the bus, then the same read request address will be repeated multiple times during the reading of a tile. | Modify the transaction generator within the DMA engine to send the exact address it received from the dataflow controller as the read/write address in its requests. Even if this implementation makes for worse performance, it gives flexibility on the sizes of tiles which are correctly supported. |
| Response Ready Not Propogated For DMA Demux When Empty Fifo | DMA_BUGID2 | axi_demux.sv | The dma engine uses a demux to syncronize or choose who to transmit to/from next. This is the mechanism that selects to either read/write to/from memory or read/write to/from SRAMs. The logic for the response ready and assertion between masters and slaves, depend on the w fifo not being empty. If it is, then dma responses ready never asserts and the transaction never completes. | Remove the fifo not empty condition from the master response logic. |
| Response Ready Not Propogated For DMA Demux When Empty Fifo | DMA_BUGID3 | fifo_v3.sv | The dma engine uses a demux to syncronize or choose who to transmit to/from next. This is the mechanism that selects to either read/write to/from memory or read/write to/from SRAMs. When the fifo is empty, the last value in the fifo gets sent out as the select, causing the demux to choose the incorrect port (MEM v SRAM) as the next interaction, leading to blocking of the dataflow and execution of the subsystem | Remove the fifo not empty condition from the master response logic. |

## Doc Issues 
| Title               | BUG_ID  | File    |Description           | Proposed Fix               |
|--------------------|-------|-------|-----------|------------------|
| Weights Tile Forced To Be Read Over Multiple Iterations | DOC_MISS1 | sauria_interface.sv | The formula for weights W limit contains a comment which shows the expectation that the weights tile will be transferred using a single DMA transfer. Looking at the formula of how weights w limit is calculated, the only case which leads to a single DMA transfer reading the entire weights tile is by setting tile weights c step equal to weights w step, that way weights w limit is 0 which results in a single iteration. In all other configurations the result is multiple dma transfers to read a weights tile.| No proposed fix. Comment does not affect functionality or correctness. Only incorrect expectation observed. | 

       